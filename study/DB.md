[Back to main](/README.md)
# DB

<details>
<summary> 트랜잭션 </summary>

- 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위
- 트랜잭션은 작업의 완전성을 보장해주는 것
- 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 만들어주는 것
- 하나의 트랜잭션은 Commit 되거나 Rollback 됨
  
### 트랜잭션의 특성 ACID
1. 원자성 (Atomicity)
   - 작업이 모두 반영되거나 모두 반영되지 않아야 함
2. 일관성 (Consistency)
   - 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 함
3. 독립성 (Isolation)
   - 둘 이상의 트랜잭션이 동시에 실행될 경우 서로 연산에 끼어들 수 없어야함
4. 영속성 (Durability)
   - 완료된 결과는 영구적으로 반영되어야함

### 트랜잭션의 상태


### 트랜잭션

</details>

<details>
<summary> Indexing </summary>

- Index란 테이블을 처음부터 끝까지 검색하지 않고 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법

- 인덱스는 항상 정렬된 상태를 유지하며 메모리 영역에 일종의 목차를 생성하는 것으로, 검색의 범위를 줄여 속도를 높일 수 있으나
- 새로운 값을 추가하거나 수정할 경우 쿼리문에 실행 속도가 느려진다는 단점이 있음

- 하나의 쇼핑몰에 여러가지 카테고리가 존재해 해당 카테고리의 상품을 조회 시 인덱스 기능을 활용한다면 큰 효율을 발휘하지만
- 인스타그램과 같은 소셜 서비스처럼 게시글의 작성, 수정, 삭제가 많은 서비스에서는 성능이 저하됨

</details>

<details>
<summary> RDBMS vs NoSQL </summary>

### RDBMS
관계형 데이터베이스 관리 시스템의 약자로 관계형 데이터베이스를 관리하는 시스템
- 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 DB
  - 장점
    - 스키마에 따라 데이터를 저장해야하여 명확한 데이터 구조를 보장
    - 각 데이터를 중복 없이 한번만 저장할 수 있음
  - 단점
    - 시스템이 커질수록 쿼리가 복잡해지고 성능이 저하됨
    - 스키마로 인해 데이터가 유연하지 못함

- 테이블간의 관계에서 외래 키를 이용한 테이블 간 Join이 가능하다는게 큰 특징
- 수직적 확장

### NoSQL
Not only SQL의 약자, RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리, 컬렉션이라는 형태로 데이터를 관리
- 장점
  - 스키마 없어 자유로운 데이터 구조를 가짐
  - 언제든 저장된 데이터를 조정하고 새로운 필드 수정 가능
- 단점 
  - 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 함
  - 스키마가 없어 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있음
- 수평적 확장

### 차이점
- 스키마가 있고 없는 것이 가장 큰 차이점.
- RDBMS는 스키마가 있기에 명확한 데이터 구조를 보장하지만, 데이터가 유연하지 못하고 NoSQL은 스키마가 없어 자유로운 데이터 구조를 가질 수 있지만, 데이터 구조 결정이 어려울 수 있음

</details>

<details>
<summary> DB 정규화 </summary>
하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법

### 정규화는 왜 하는가
- 불필요한 데이터를 제거해 불필요한 중복을 최소화
- 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상을 방지하기 위해, 구성을 논리적이고 직관적으로 하고자 정규화
  - 삽입 이상: 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 Null을 입력
  - 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
  - 삭제 이상: 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

### 정규화 과정 
- 제1 정규형
  - 테이블의 컬럼이 하나의 값을 갖도록 분해
- 제2 정규형
  - 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해 
  - 완전 함수 종속: 기본키의 부분 집합이 다른 값을 결정하지 않는 것
- 제3 정규형
  - 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해
  - A -> B, B -> C 일때 A -> C가 성립되어야함
- BCNF 정규형
  - 제3 정규형을 만족하고, 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해
- 제4 정규형
  - BCNF 정규형을 만족하고 다치 종속이 없어야 함
  - 다치 종속: 최소 3개의 컬럼이 있고 (A,B,C) 에서 A->B와 A->C인 경우에 B와 C가 독립적
    - A->B 일때 하나의 A값에 여러 개의 B값이 존재하면 다치 종속성
- 제5 정규형
  - 제4 정규형을 만족하고, 조인 종속이 없어야하며 조인 연산을 했을 때 손실이 없어야 함
  - 중복을 제거하기 위해 분해할 수 있을 만큼 전부 분해하는 것

### 정규화의 단점
- 릴레이션의 분해로 인해 릴레이션 간의 조인 연산이 많아짐, 이로 인해 질의에 대한 응답 시간이 느려질 수 있음

### 역정규화
- 정규화를 거쳐 조인 연산이 많아진 경우, 이로 인해 성능이 저하될 우려가 있음
- 성능 문제가 있는 (읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함

</details>

<details>
<summary> SQL Injection </summary>

- SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 DB를 비정상적으로 조작하는 공격 기법

</details> 

<details>
<summary> 파티셔닝 </summary>

- DB를 여러 부분으로 분할하는 방법, DB가 너무 커져서 조회하는 시간이 길어질 때 성능 이슈를 방지하고자 사용

- 수직 파티셔닝
  - 같은 DB 내에서 분할
  - 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것
- 샤딩
  - 다른 DB를 하나 더 파는 것
  - 다른 DB에 하나의 테이블의 각 행을 분산시키는 것

</details> 

<!-- 
<details>
<summary> </summary>

</details> 
-->